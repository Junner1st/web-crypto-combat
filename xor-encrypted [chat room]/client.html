<!DOCTYPE html>
<html>
<head>
  <title>Secure Chat Client</title>
  <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
</head>
<body>
  <h1>Secure Chat</h1>
  <div id="messages"></div>
  <input id="messageInput" placeholder="Type your message here" />
  <button onclick="sendMessage()">Send</button>

  <script>
    const socket = io("http://localhost:5055");
    let clientId = null;
    let rsaKeyPair = null;
    let aesKey = null;
    const rsaPublicKeys = {}; // { sid: rsaKey }
    const initialVector = crypto.getRandomValues(new Uint8Array(16));
    let temp_iv = CryptoJS.lib.WordArray.create(initialVector);
    console.log(`create initialVector: ${temp_iv}`);
    console.log(typeof temp_iv, temp_iv.sigBytes, temp_iv.words, temp_iv.toString(CryptoJS.enc.Hex))
    

    function log(msg) {
      console.log(`[Log] ${msg}`);
    }

    async function generateRSAKeyPair() {
      return crypto.subtle.generateKey({
        name: "RSA-OAEP",
        modulusLength: 2048,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: "SHA-256"
      }, true, ["encrypt", "decrypt"]);
    }

    async function exportRSAPublicKey(publicKey) {
      const spki = await crypto.subtle.exportKey("spki", publicKey);
      return btoa(String.fromCharCode(...new Uint8Array(spki)));
    }

    async function importRSAPublicKey(spkiString) {
      const buffer = Uint8Array.from(atob(spkiString), c => c.charCodeAt(0));
      return crypto.subtle.importKey("spki", buffer, {
        name: "RSA-OAEP",
        hash: "SHA-256"
      }, true, ["encrypt"]);
    }

    async function generateAESKey() {
      key = CryptoJS.lib.WordArray.create(crypto.getRandomValues(new Uint8Array(16)));
      log(`Generated AES key: ${key}`);
      console.log(typeof key, key.sigBytes, key.words, key.toString(CryptoJS.enc.Hex))
      return key;
    }


    async function encryptOFB(plaintext, key, ivWordArray, decrypt = false) {
      let iv = ivWordArray;
      // log(`initialVector: ${iv}`);
      // console.log(typeof iv, iv.sigBytes, iv.words, iv.toString(CryptoJS.enc.Hex))
      const blockSize = 16;

      textHex = null;
      if (!decrypt) {
        const textBytes = CryptoJS.enc.Utf8.parse(plaintext);
        textHex = textBytes.toString(CryptoJS.enc.Hex);
      } else {
        textHex = plaintext;
      }

      const blocks = [];
      // console.log(blocks)
      for (let i = 0; i < textHex.length; i += blockSize * 2) {
        blocks.push(textHex.slice(i, i + blockSize * 2));
      }

      let ciphertextHex = "";

      blocks.forEach((blockHex, index) => {
        const keystream = CryptoJS.AES.encrypt(iv, key, { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.NoPadding }).ciphertext;
        // console.log(`keystream: ${keystream} with decrypt? ${decrypt}`);

        let block = CryptoJS.enc.Hex.parse(blockHex.padEnd(blockSize * 2, '0')); // pad 0s
        const cipherBlock = block.clone();

        
        length = block.sigBytes / 4;
        for (let i = 0; i < length; i++) {
          cipherBlock.words[i] ^= keystream.words[i];
        }    

        const resultHex = CryptoJS.enc.Hex.stringify(cipherBlock).slice(0, blockHex.length);
        ciphertextHex += resultHex;

        iv = keystream;
      });

      if (!decrypt) {
        console.log(`ciphertext (Hex): ${ciphertextHex}`);
        return ciphertextHex;
      } else {
        const decrypted = CryptoJS.enc.Hex.parse(ciphertextHex);
        const decryptedUtf8 = CryptoJS.enc.Utf8.stringify(decrypted);
        console.log(`decrypted ciphertext (Utf8): ${decryptedUtf8}`);
        return decryptedUtf8;
      }
    }


    async function encryptWithRSA(publicKey, data) {
      return crypto.subtle.encrypt({ name: "RSA-OAEP" }, publicKey, data);
    }

    async function decryptWithRSA(privateKey, data) {
      return crypto.subtle.decrypt({ name: "RSA-OAEP" }, privateKey, data);
    }

    async function encryptWithAES(key, data) {
      iv = CryptoJS.lib.WordArray.create(initialVector);
      const enc = await encryptOFB(data, key, iv);
      return { iv: iv, data: enc };
    }

    async function decryptWithAES(key, message, init_vec) {
      return await encryptOFB(message, key, init_vec, true);
    }

    async function sendAESToClient(sid) {
      const pubKey = rsaPublicKeys[sid];
      const aesString = aesKey.toString(CryptoJS.enc.Hex);
      key = new TextEncoder().encode(aesString);      

      encrypted = await encryptWithRSA(pubKey, key);
      socket.emit("send_aes_to_newcomer", { target_sid: sid, encrypted_aes: btoa(String.fromCharCode(...new Uint8Array(encrypted))) });
      log(`Encrypted and sent AES key to ${sid}`);
    }

    socket.on("connect", async () => {
      clientId = socket.id;
      log(`Connected with id: ${clientId}`);
    });

    socket.on("connect_ack", async ({ user_list }) => {
      log(`Received register_ack. User list: ${user_list.join(", ")}`);

      if (user_list.length === 0) {
        //// The first client generate AES key
        log("No users present. Generating AES key as first client.");
        aesKey = await generateAESKey();
      } else if (user_list.length !== 0) {
        //// if there are users, generate RSA key pair and send public key
        rsaKeyPair = await generateRSAKeyPair();
        log("Generated RSA key pair and exported public key.");

        const publicKeyString = await exportRSAPublicKey(rsaKeyPair.publicKey);
        socket.emit("register", { rsa_key: publicKeyString });
        log("Sent register event with RSA public key.");
      } else {
        log("condition sus à¶ž");
      }
    });

    socket.on("receive_rsa_key", async ({ sid, rsa_key }) => {
      log(`Received RSA public key from ${sid}`);
      const pubKey = await importRSAPublicKey(rsa_key);
      rsaPublicKeys[sid] = pubKey;

      if (aesKey) {
        await sendAESToClient(sid);
      }
    });

    socket.on("receive_aes_key", async ({ encrypted_aes }) => {
      log("Received encrypted AES key.");
      const decoded = Uint8Array.from(atob(encrypted_aes), c => c.charCodeAt(0));
      const decrypted = await decryptWithRSA(rsaKeyPair.privateKey, decoded);
      aesKey = new TextDecoder().decode(decrypted);
      aesKey = CryptoJS.enc.Hex.parse(aesKey);

      log(`Recieved AES key: ${aesKey}`);
      console.log(typeof aesKey, aesKey.sigBytes, aesKey.words, aesKey.toString(CryptoJS.enc.Hex))
    });



    socket.on("receive_message", async ({ sender, message, iv }) => {
      
      const decrypted = await decryptWithAES(aesKey, message, iv);
      const plaintext = decrypted;
      log(`Received message from ${sender}: ${plaintext}`);
      document.getElementById("messages").innerHTML += `<p><b>${sender}:</b> ${plaintext}</p>`;
    });

    async function sendMessage() {
      const input = document.getElementById("messageInput");
      const message = input.value;
      const payload = await encryptWithAES(aesKey, message);

      socket.emit("send_message", { "payload": JSON.stringify(payload) });
      log(`Sent message: ${message}`);
      input.value = "";
    }
  </script>
</body>
</html>
