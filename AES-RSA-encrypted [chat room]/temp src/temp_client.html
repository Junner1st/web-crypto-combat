<!DOCTYPE html>
<html>
<head>
  <title>Secure Chat Client</title>
  <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
</head>
<body>
  <h1>Secure Chat</h1>
  <div id="messages"></div>
  <input id="messageInput" placeholder="Type your message here" />
  <button onclick="sendMessage()">Send</button>

  <script>
    const socket = io("http://localhost:5055");
    let clientId = null;
    let rsaKeyPair = null;
    let aesKey = null;
    const rsaPublicKeys = {}; // { sid: rsaKey }

    function log(msg) {
      console.log(`[Log] ${msg}`);
    }

    async function generateRSAKeyPair() {
      return crypto.subtle.generateKey({
        name: "RSA-OAEP",
        modulusLength: 2048,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: "SHA-256"
      }, true, ["encrypt", "decrypt"]);
    }

    async function exportRSAPublicKey(publicKey) {
      const spki = await crypto.subtle.exportKey("spki", publicKey);
      return btoa(String.fromCharCode(...new Uint8Array(spki)));
    }

    async function importRSAPublicKey(spkiString) {
      const buffer = Uint8Array.from(atob(spkiString), c => c.charCodeAt(0));
      return crypto.subtle.importKey("spki", buffer, {
        name: "RSA-OAEP",
        hash: "SHA-256"
      }, true, ["encrypt"]);
    }

    async function generateAESKey() {
      return crypto.subtle.generateKey({
        name: "AES-GCM",
        length: 256
      }, true, ["encrypt", "decrypt"]);
    }

    async function exportAESKey(key) {
      const raw = await crypto.subtle.exportKey("raw", key);
      return btoa(String.fromCharCode(...new Uint8Array(raw)));
    }

    async function importAESKey(base64) {
      const raw = Uint8Array.from(atob(base64), c => c.charCodeAt(0));
      return crypto.subtle.importKey("raw", raw, "AES-GCM", true, ["encrypt", "decrypt"]);
    }

    async function encryptWithRSA(publicKey, data) {
      return crypto.subtle.encrypt({ name: "RSA-OAEP" }, publicKey, data);
    }

    async function decryptWithRSA(privateKey, data) {
      return crypto.subtle.decrypt({ name: "RSA-OAEP" }, privateKey, data);
    }

    async function encryptWithAES(key, data) {
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const enc = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, data);
      return { iv: btoa(String.fromCharCode(...iv)), data: btoa(String.fromCharCode(...new Uint8Array(enc))) };
    }

    async function decryptWithAES(key, message, init_vec) {
      payload = {
        iv: init_vec,
        data: message
      };
      const iv = Uint8Array.from(atob(payload.iv), c => c.charCodeAt(0));
      const data = Uint8Array.from(atob(payload.data), c => c.charCodeAt(0));
      return crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, data);
    }

    socket.on("connect", async () => {
      clientId = socket.id;
      log(`Connected with id: ${clientId}`);
    });

    socket.on("connect_ack", async ({ user_list }) => {
      log(`Received register_ack. User list: ${user_list.join(", ")}`);

      if (user_list.length === 0) {
        //// The first client generate AES key
        log("No users present. Generating AES key as first client.");
        aesKey = await generateAESKey();
      } else if (user_list.length !== 0) {
        //// if there are users, generate RSA key pair and send public key
        rsaKeyPair = await generateRSAKeyPair();
        log("Generated RSA key pair and exported public key.");

        const publicKeyString = await exportRSAPublicKey(rsaKeyPair.publicKey);
        socket.emit("register", { rsa_key: publicKeyString });
        log("Sent register event with RSA public key.");
      } else {
        log("condition sus à¶ž");
      }
    });

    socket.on("receive_rsa_key", async ({ sid, rsa_key }) => {
      log(`Received RSA public key from ${sid}`);
      const pubKey = await importRSAPublicKey(rsa_key);
      rsaPublicKeys[sid] = pubKey;

      if (aesKey) {
        await sendAESToClient(sid);
      }
    });

    socket.on("receive_aes_key", async ({ encrypted_aes }) => {
      log("Received encrypted AES key.");
      const decoded = Uint8Array.from(atob(encrypted_aes), c => c.charCodeAt(0));
      const decrypted = await decryptWithRSA(rsaKeyPair.privateKey, decoded);
      const aesStr = new TextDecoder().decode(decrypted);
      aesKey = await importAESKey(aesStr);
      log("Decrypted and imported AES key.");
      log(`AES key imported: ${aesKey}`);
    });

    socket.on("server_requests_aes_resend", async ({ target_sid }) => {
      log(`Received server request to send AES key to ${target_sid}`);
      if (aesKey && rsaPublicKeys[target_sid]) {
        await sendAESToClient(target_sid);
      } else {
        log("Missing AES key or RSA public key for target.");
      }
    });

    async function sendAESToClient(sid) {
      const pubKey = rsaPublicKeys[sid];
      const aesString = await exportAESKey(aesKey);
      const encrypted = await encryptWithRSA(pubKey, new TextEncoder().encode(aesString));
      socket.emit("send_aes_to_newcomer", { target_sid: sid, encrypted_aes: btoa(String.fromCharCode(...new Uint8Array(encrypted))) });
      log(`Encrypted and sent AES key to ${sid}`);
    }

    socket.on("receive_message", async ({ sender, message, iv }) => {
      const decrypted = await decryptWithAES(aesKey, message, iv);
      const plaintext = new TextDecoder().decode(decrypted);
      log(`Received message from ${sender}: ${plaintext}`);
      document.getElementById("messages").innerHTML += `<p><b>${sender}:</b> ${plaintext}</p>`;
    });

    async function sendMessage() {
      const input = document.getElementById("messageInput");
      const message = input.value;
      const payload = await encryptWithAES(aesKey, new TextEncoder().encode(message));
      socket.emit("send_message", { "payload": JSON.stringify(payload) });
      log(`Sent message: ${message}`);
      input.value = "";
    }
  </script>
</body>
</html>
